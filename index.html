<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pocket Pose Coach</title>
  <meta name="description" content="–û–Ω-–ª–∞–π–Ω —Ç—Ä–µ–Ω—å–æ—Ä –∑–∞ –ø–æ–∑–∞ –∏ –ø—Ä–µ—Ö–æ–¥–∏ —Å –∏–Ω–µ—Ä—Ü–∏—è. –†–∞–±–æ—Ç–∏ –∏–∑—Ü—è–ª–æ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ—Ç–æ."/>
  <style>
    :root { --bg:#0b0b0f; --fg:#e7e7ea; --muted:#9aa0a6; --accent:#7bc8ff; --bad:#ff6b6b; --ok:#ffd166; --good:#06d6a0; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji'; background:var(--bg); color:var(--fg); }
    header { padding: 14px 16px; display:flex; align-items:center; gap:12px; border-bottom:1px solid #23242a; position:sticky; top:0; background:rgba(11,11,15,0.9); backdrop-filter:saturate(150%) blur(8px); z-index:10; }
    header h1 { font-size: 18px; margin: 0; letter-spacing: 0.5px;}
    main { display:grid; grid-template-columns: 1fr; gap: 12px; padding: 12px; max-width: 980px; margin: 0 auto; }
    #stage { position: relative; width: 100%; aspect-ratio: 16/9; border-radius: 16px; overflow: hidden; background:#0e1117; box-shadow: 0 8px 30px rgba(0,0,0,.35); }
    video { position:absolute; inset:0; width:100%; height:100%; object-fit: cover; transform: scaleX(-1); }
    canvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; transform: scaleX(-1); }
    .toolbar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .toolbar > * { flex: none; }
    select, button, input[type="checkbox"]+label { border:1px solid #2a2b31; background:#14151b; color:var(--fg); padding:10px 12px; border-radius:12px; font-size:14px; }
    button.primary { background:linear-gradient(180deg, #2b9eff, #0078ff); border:none; }
    .pill { padding:6px 10px; background:#14151b; border:1px solid #2a2b31; border-radius:999px; font-size:12px; color:var(--muted); }
    .grid { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:12px; }
    .card { background:#0f1218; border:1px solid #1e222b; border-radius:16px; padding:12px; }
    .score { font-size: 28px; font-weight:700; }
    .score.good { color:var(--good); }
    .score.ok { color:var(--ok); }
    .score.bad { color:var(--bad); }
    .tips { display:flex; gap:8px; flex-wrap:wrap; }
    .tip { font-size:12px; padding:8px 10px; border-radius:10px; border:1px dashed #2a2b31; background:#12141a; }
    footer { padding:10px 16px; color:var(--muted); text-align:center; }
    .small { font-size:12px; color:var(--muted); }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .spacer { flex:1 }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.js" crossorigin="anonymous"></script>
</head>
<body>
  <header>
    <h1>üé• Pocket Pose Coach</h1>
    <span class="pill">–æ–Ω-—É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ ¬∑ –±–µ–∑ –æ–±–ª–∞–∫</span>
    <span class="pill" id="status">–∑–∞—Ä–µ–∂–¥–∞ –º–æ–¥–µ–ª‚Ä¶</span>
    <span class="spacer"></span>
    <button id="btnStart" class="primary">–°—Ç–∞—Ä—Ç –∫–∞–º–µ—Ä–∞</button>
  </header>

  <main>
    <div id="stage">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay"></canvas>
    </div>

    <div class="toolbar">
      <label for="facing">–ö–∞–º–µ—Ä–∞:</label>
      <select id="facing">
        <option value="environment">–ó–∞–¥–Ω–∞</option>
        <option value="user">–ü—Ä–µ–¥–Ω–∞</option>
      </select>

      <label for="move">–î–≤–∏–∂–µ–Ω–∏–µ:</label>
      <select id="move">
        <option value="toprock">Top Rock (basic) ‚Äî –±–µ—Ç–∞</option>
        <option value="squat">–ö–ª–µ–∫</option>
        <option value="plank">–ü–ª–∞–Ω–∫</option>

        <option value="transition_ts">Transition: TopRock ‚Üí Squat</option>
        <option value="transition_indian_kneedrop">Transition: Indian Step ‚Üí Knee Drop</option>
        <option value="transition_toprock_drop">Transition: TopRock ‚Üí Drop to Floor</option>
        <option value="transition_sixstep_babyfreeze">Transition: Six-Step ‚Üí Baby Freeze</option>

        <option value="transition_toprock_kneedrop">Transition: TopRock ‚Üí Knee Drop</option>
        <option value="transition_toprock_sweepdrop">Transition: TopRock ‚Üí Sweep Drop</option>
        <option value="transition_toprock_spindrop">Transition: TopRock ‚Üí Spin Drop</option>
        <option value="transition_toprock_hookdrop">Transition: TopRock ‚Üí Hook Drop</option>
        <option value="transition_toprock_collapsedrop">Transition: TopRock ‚Üí Collapse Drop</option>
        <option value="transition_toprock_rolldrop">Transition: TopRock ‚Üí Roll Drop</option>
        <option value="transition_toprock_suicidedrop">Transition: TopRock ‚Üí Suicide Drop</option>
      </select>

      <div class="row">
        <input id="voice" type="checkbox" checked />
        <label for="voice">–ì–ª–∞—Å–æ–≤–∏ —Å—ä–≤–µ—Ç–∏</label>
      </div>
      <div class="row">
        <input id="mirror" type="checkbox" checked />
        <label for="mirror">–û–≥–ª–µ–¥–∞–ª–µ–Ω —Ä–µ–∂–∏–º</label>
      </div>
    </div>

    <div class="card"><div><b>–°—Ç–∞—Ç—É—Å / –õ–æ–≥</b></div><div id="log" class="small" style="white-space:pre-wrap; max-height:120px; overflow:auto; margin-top:6px;"></div></div>

    <div class="grid">
      <div class="card">
        <div>–û—Ü–µ–Ω–∫–∞</div>
        <div id="score" class="score">‚Äî</div>
        <div class="small">0‚Äì59: –Ω—É–∂–¥–∞ –æ—Ç –∫–æ—Ä–µ–∫—Ü–∏–∏ ¬∑ 60‚Äì79: –æ–∫ ¬∑ 80‚Äì100: –æ—Ç–ª–∏—á–Ω–æ</div>
      </div>
      <div class="card">
        <div class="row"><b>–†–∏—Ç—ä–º</b> <span class="spacer"></span><span id="tempo" class="pill">‚Äî</span></div>
        <div class="small">–°–∞–º–æ –∑–∞ Top Rock: –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª–Ω–∏ —Å—Ç—ä–ø–∫–∏ –≤ –º–∏–Ω—É—Ç–∞</div>
      </div>
    </div>

    <div class="card">
      <div>–°—ä–≤–µ—Ç–∏ –≤ —Ä–µ–∞–ª–Ω–æ –≤—Ä–µ–º–µ</div>
      <div id="tips" class="tips"></div>
    </div>

    <footer class="small">
      –†–∞–±–æ—Ç–∏ —Å <a href="https://ai.google.dev/edge/mediapipe/solutions/vision/pose_landmarker/web_js" target="_blank" rel="noreferrer">MediaPipe Pose Landmarker</a>.
      –î–∞–Ω–Ω–∏—Ç–µ –Ω–µ –Ω–∞–ø—É—Å–∫–∞—Ç —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ—Ç–æ.
    </footer>
  </main>

<script>
const { FilesetResolver, PoseLandmarker, DrawingUtils } = window;
function logMsg(t){ try{ const el=document.getElementById("log"); if(el){ el.textContent += (t+"\\n"); el.scrollTop = el.scrollHeight; } }catch(e){} }
function setStatus(t){ const el=document.getElementById("status"); if(el) el.textContent=t; logMsg(t); }

let landmarker = null;
let running = false;
let videoEl, canvasEl, ctx;
let drawing;
let lastVideoTime = -1;
let lastStepSide = 0; // -1 L, +1 R
let lastStepTs = 0;
let bpmAvg = [];

const LM = {
  NOSE:0, LEFT_SHOULDER:11, RIGHT_SHOULDER:12, LEFT_ELBOW:13, RIGHT_ELBOW:14,
  LEFT_WRIST:15, RIGHT_WRIST:16, LEFT_HIP:23, RIGHT_HIP:24, LEFT_KNEE:25, RIGHT_KNEE:26,
  LEFT_ANKLE:27, RIGHT_ANKLE:28
};

function vec(a,b){ return {x:b.x-a.x, y:b.y-a.y}; }
function mag(v){ return Math.hypot(v.x, v.y); }
function dot(a,b){ return a.x*b.x + a.y*b.y; }
function angle(a,b,c){
  const v1 = vec(b,a), v2 = vec(b,c);
  const cos = (dot(v1,v2)) / (mag(v1)*mag(v2) + 1e-6);
  return Math.acos(Math.min(1, Math.max(-1, cos))) * 180/Math.PI;
}
function torsoTiltDeg(lm){
  const s = mid(lm[LM.LEFT_SHOULDER], lm[LM.RIGHT_SHOULDER]);
  const h = mid(lm[LM.LEFT_HIP], lm[LM.RIGHT_HIP]);
  const v = {x: s.x-h.x, y: s.y-h.y};
  const up = {x:0, y:-1};
  const cos = (dot(v,up)) / (mag(v)*mag(up) + 1e-6);
  return Math.acos(Math.min(1, Math.max(-1, cos))) * 180/Math.PI;
}
function mid(a,b){ return {x:(a.x+b.x)/2, y:(a.y+b.y)/2}; }
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function within(val, min, max){ return val>=min && val<=max; }

function speak(txt){
  if(!document.getElementById('voice').checked) return;
  try{
    const u = new SpeechSynthesisUtterance(txt);
    u.lang = 'bg-BG';
    u.rate = 1.0;
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(u);
  }catch(e){}
}

const MOVES = {
  squat: {
    name: "–ö–ª–µ–∫",
    constraints: [
      { id:"back", test:(lm)=> torsoTiltDeg(lm) < 15, tip:"–ò–∑–ø—Ä–∞–≤–∏ —Ç–æ—Ä—Å–∞ (<15¬∞ –Ω–∞–∫–ª–æ–Ω)." },
      { id:"kneesLeft", test:(lm)=> Math.abs(lm[LM.LEFT_KNEE].x - lm[LM.LEFT_ANKLE].x) < 0.06, tip:"–õ—è–≤–æ—Ç–æ –∫–æ–ª—è–Ω–æ –¥–∞ –µ –Ω–∞–¥ —Å—Ç—ä–ø–∞–ª–æ—Ç–æ." },
      { id:"kneesRight", test:(lm)=> Math.abs(lm[LM.RIGHT_KNEE].x - lm[LM.RIGHT_ANKLE].x) < 0.06, tip:"–î—è—Å–Ω–æ—Ç–æ –∫–æ–ª—è–Ω–æ –¥–∞ –µ –Ω–∞–¥ —Å—Ç—ä–ø–∞–ª–æ—Ç–æ." },
      { id:"depth", test:(lm)=> (lm[LM.LEFT_HIP].y < lm[LM.LEFT_KNEE].y) || (lm[LM.RIGHT_HIP].y < lm[LM.RIGHT_KNEE].y), tip:"–°–ª—è–∑—ä–ª/–∞ —Å–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç—ä—á–Ω–æ (–±–µ–¥—Ä–æ—Ç–æ –ø–æ–¥ —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∞)." }
    ]
  },
  plank: {
    name:"–ü–ª–∞–Ω–∫",
    constraints:[
      { id:"line", test:(lm)=> {
          const a = angle(lm[LM.LEFT_SHOULDER], lm[LM.LEFT_HIP], lm[LM.LEFT_ANKLE]);
          const b = angle(lm[LM.RIGHT_SHOULDER], lm[LM.RIGHT_HIP], lm[LM.RIGHT_ANKLE]);
          return within(a,165,180) && within(b,165,180);
        }, tip:"–ï–¥–Ω–∞ –ª–∏–Ω–∏—è –æ—Ç —Ä–∞–º–æ –¥–æ –≥–ª–µ–∑–µ–Ω." },
      { id:"hips", test:(lm)=> {
          const s = mid(lm[LM.LEFT_SHOULDER], lm[LM.RIGHT_SHOULDER]);
          const h = mid(lm[LM.LEFT_HIP], lm[LM.RIGHT_HIP]);
          const ratio = (h.y - s.y);
          return ratio > 0.10 && ratio < 0.28;
        }, tip:"–ù–µ –≤–¥–∏–≥–∞–π/—Å–≤–∞–ª—è–π —Ç–∞–∑–∞." }
    ]
  },
  toprock: {
    name:"Top Rock (basic)",
    constraints:[
      { id:"shoulders", test:(lm)=> Math.abs(lm[LM.LEFT_SHOULDER].y - lm[LM.RIGHT_SHOULDER].y) < 0.06, tip:"–î—Ä—ä–∂ —Ä–∞–º–µ–Ω–µ—Ç–µ —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ." },
      { id:"stance", test:(lm)=> {
          const shoulderW = Math.abs(lm[LM.LEFT_SHOULDER].x - lm[LM.RIGHT_SHOULDER].x);
          const footW = Math.abs(lm[LM.LEFT_ANKLE].x - lm[LM.RIGHT_ANKLE].x);
          return footW >= 0.75*shoulderW;
        }, tip:"–û—Ç–≤–æ—Ä–∏ —Å—Ç—ä–ø–∫–∞—Ç–∞ ‚â• —à–∏—Ä–∏–Ω–∞ –Ω–∞ —Ä–∞–º–µ–Ω–µ." },
      { id:"upright", test:(lm)=> torsoTiltDeg(lm) < 20, tip:"–ò–∑–ø—Ä–∞–≤–∏ —Ç–æ—Ä—Å–∞." }
    ],
    stepDetector:(lm, ts)=>{
      const diff = lm[LM.RIGHT_ANKLE].x - lm[LM.LEFT_ANKLE].x;
      const side = diff > 0.08 ? +1 : (diff < -0.08 ? -1 : 0);
      let bpm = null;
      if(side !== 0 && side !== lastStepSide){
        const now = ts;
        if(lastStepTs>0){
          const dt = (now - lastStepTs)/1000;
          const spm = 60/dt;
          const stepsPerMin = spm * 1.0;
          bpm = stepsPerMin;
          bpmAvg.push(stepsPerMin);
          if(bpmAvg.length>6) bpmAvg.shift();
        }
        lastStepTs = now;
        lastStepSide = side;
      }
      return bpm;
    }
  }
};

// --- Transition profiles ---
const TRANSITIONS = {
  transition_ts: {
    name: "TopRock ‚Üí Squat",
    type: "standing",
    boundary(lm, prev){
      const hipAbove = (p)=> (p[LM.LEFT_HIP].y < p[LM.LEFT_KNEE].y*0.98) && (p[LM.RIGHT_HIP].y < p[LM.RIGHT_KNEE].y*0.98);
      const hipBelow = (c)=> (c[LM.LEFT_HIP].y > c[LM.LEFT_KNEE].y*0.98) || (c[LM.RIGHT_HIP].y > c[LM.RIGHT_KNEE].y*0.98);
      try{ return prev && hipAbove(prev) && hipBelow(lm); }catch(e){ return false; }
    }
  },
  transition_indian_kneedrop: {
    name: "Indian Step ‚Üí Knee Drop",
    type: "standing",
    boundary(lm, prev){
      const kneeAngleL = angle(lm[LM.LEFT_HIP], lm[LM.LEFT_KNEE], lm[LM.LEFT_ANKLE]);
      const kneeAngleR = angle(lm[LM.RIGHT_HIP], lm[LM.RIGHT_KNEE], lm[LM.RIGHT_ANKLE]);
      const sharpFlex = (kneeAngleL<75) || (kneeAngleR<75);
      const hipBelowKnee = (c)=> (c[LM.LEFT_HIP].y > c[LM.LEFT_KNEE].y*0.98) || (c[LM.RIGHT_HIP].y > c[LM.RIGHT_KNEE].y*0.98);
      try{ return prev && sharpFlex && hipBelowKnee(lm); }catch(e){ return false; }
    }
  },
  transition_toprock_drop: {
    name: "TopRock ‚Üí Drop to Floor",
    type: "standing",
    boundary(lm, prev){
      const handsLow = (c)=> (c[LM.LEFT_WRIST].y > c[LM.LEFT_KNEE].y*0.98) || (c[LM.RIGHT_WRIST].y > c[LM.RIGHT_KNEE].y*0.98);
      const hipsLow = (c)=> (c[LM.LEFT_HIP].y > c[LM.LEFT_KNEE].y*0.95) || (c[LM.RIGHT_HIP].y > c[LM.RIGHT_KNEE].y*0.95);
      try{ return prev && handsLow(lm) && hipsLow(lm); }catch(e){ return false; }
    }
  },
  transition_sixstep_babyfreeze: {
    name: "Six-Step ‚Üí Baby Freeze",
    type: "floor",
    boundary(lm, prev){
      function near(a,b){ return dist(a,b) < 0.10; }
      const oppClose1 = near(lm[LM.LEFT_WRIST], lm[LM.RIGHT_KNEE]);
      const oppClose2 = near(lm[LM.RIGHT_WRIST], lm[LM.LEFT_KNEE]);
      const hipsVeryLow = (c)=> (c[LM.LEFT_HIP].y > Math.max(c[LM.LEFT_KNEE].y, c[LM.RIGHT_KNEE].y) * 0.98);
      const elbowsBent = ()=> {
        const aL = angle(lm[LM.LEFT_SHOULDER], lm[LM.LEFT_ELBOW], lm[LM.LEFT_WRIST]);
        const aR = angle(lm[LM.RIGHT_SHOULDER], lm[LM.RIGHT_ELBOW], lm[LM.RIGHT_WRIST]);
        return (aL<150) || (aR<150);
      };
      try{ return prev && (oppClose1||oppClose2) && hipsVeryLow(lm) && elbowsBent(); }catch(e){ return false; }
    }
  },
  transition_toprock_kneedrop: {
    name: "TopRock ‚Üí Knee Drop",
    type: "standing",
    boundary(lm, prev){
      const kneeAngleL = angle(lm[LM.LEFT_HIP], lm[LM.LEFT_KNEE], lm[LM.LEFT_ANKLE]);
      const kneeAngleR = angle(lm[LM.RIGHT_HIP], lm[LM.RIGHT_KNEE], lm[LM.RIGHT_ANKLE]);
      const sharpFlex = (kneeAngleL<75) || (kneeAngleR<75);
      const hipBelowKnee = (c)=> (c[LM.LEFT_HIP].y > c[LM.LEFT_KNEE].y*0.98) || (c[LM.RIGHT_HIP].y > c[LM.RIGHT_KNEE].y*0.98);
      try{ return prev && sharpFlex && hipBelowKnee(lm); }catch(e){ return false; }
    }
  },
  transition_toprock_sweepdrop: {
    name: "TopRock ‚Üí Sweep Drop",
    type: "standing",
    boundary(lm, prev){
      function ankleSpeed(curr, prev, side){
        const A = side==='L'? LM.LEFT_ANKLE : LM.RIGHT_ANKLE;
        const dx = Math.abs(curr[A].x - prev[A].x);
        const dy = Math.abs(curr[A].y - prev[A].y);
        return Math.hypot(dx,dy);
      }
      const hipsLow = (c)=> (c[LM.LEFT_HIP].y > c[LM.LEFT_KNEE].y*0.96) || (c[LM.RIGHT_HIP].y > c[LM.RIGHT_KNEE].y*0.96);
      try{
        if(!prev) return false;
        const vL = ankleSpeed(lm, prev, 'L');
        const vR = ankleSpeed(lm, prev, 'R');
        const fastFoot = (vL>0.02) || (vR>0.02);
        return fastFoot && hipsLow(lm);
      }catch(e){ return false; }
    }
  },
  transition_toprock_spindrop: {
    name: "TopRock ‚Üí Spin Drop",
    type: "standing",
    boundary(lm, prev){
      function shoulderAngle(p){
        const v = vec(p[LM.LEFT_SHOULDER], p[LM.RIGHT_SHOULDER]);
        return Math.atan2(v.y, v.x);
      }
      const hipsLow = (c)=> (c[LM.LEFT_HIP].y > c[LM.LEFT_KNEE].y*0.96) || (c[LM.RIGHT_HIP].y > c[LM.RIGHT_KNEE].y*0.96);
      try{
        if(!prev) return false;
        const a0 = shoulderAngle(prev), a1 = shoulderAngle(lm);
        const rot = Math.abs(a1 - a0);
        return (rot > 0.20) && hipsLow(lm);
      }catch(e){ return false; }
    }
  },
  transition_toprock_hookdrop: {
    name: "TopRock ‚Üí Hook Drop",
    type: "standing",
    boundary(lm, prev){
      function anklesCross(c){
        return Math.abs(c[LM.LEFT_ANKLE].x - c[LM.RIGHT_ANKLE].x) < 0.05;
      }
      const kneeAngleL = angle(lm[LM.LEFT_HIP], lm[LM.LEFT_KNEE], lm[LM.LEFT_ANKLE]);
      const kneeAngleR = angle(lm[LM.RIGHT_HIP], lm[LM.RIGHT_KNEE], lm[LM.RIGHT_ANKLE]);
      const sharpFlex = (kneeAngleL<85) || (kneeAngleR<85);
      const hipsLow = (c)=> (c[LM.LEFT_HIP].y > c[LM.LEFT_KNEE].y*0.96) || (c[LM.RIGHT_HIP].y > c[LM.RIGHT_KNEE].y*0.96);
      try{ return prev && anklesCross(lm) && sharpFlex && hipsLow(lm); }catch(e){ return false; }
    }
  },
  transition_toprock_collapsedrop: {
    name: "TopRock ‚Üí Collapse Drop",
    type: "standing",
    boundary(lm, prev){
      function hipVertSpeed(curr, prev){
        const hC = mid(curr[LM.LEFT_HIP], curr[LM.RIGHT_HIP]);
        const hP = mid(prev[LM.LEFT_HIP], prev[LM.RIGHT_HIP]);
        return Math.abs(hC.y - hP.y);
      }
      function ankleDelta(curr, prev){
        const dL = Math.hypot(curr[LM.LEFT_ANKLE].x - prev[LM.LEFT_ANKLE].x, curr[LM.LEFT_ANKLE].y - prev[LM.LEFT_ANKLE].y);
        const dR = Math.hypot(curr[LM.RIGHT_ANKLE].x - prev[LM.RIGHT_ANKLE].x, curr[LM.RIGHT_ANKLE].y - prev[LM.RIGHT_ANKLE].y);
        return (dL + dR)/2;
      }
      try{
        if(!prev) return false;
        const vHip = hipVertSpeed(lm, prev);
        const vAnk = ankleDelta(lm, prev);
        return (vHip>0.02) && (vAnk<0.015);
      }catch(e){ return false; }
    }
  },
  transition_toprock_rolldrop: {
    name: "TopRock ‚Üí Roll Drop",
    type: "standing",
    boundary(lm, prev){
      const shoulderLow = (c)=> (c[LM.LEFT_SHOULDER].y > c[LM.LEFT_KNEE].y) || (c[LM.RIGHT_SHOULDER].y > c[LM.RIGHT_KNEE].y);
      const wristsLow = (c)=> (c[LM.LEFT_WRIST].y > c[LM.LEFT_KNEE].y*0.98) || (c[LM.RIGHT_WRIST].y > c[LM.RIGHT_KNEE].y*0.98);
      try{ return prev && shoulderLow(lm) && wristsLow(lm); }catch(e){ return false; }
    }
  },
  transition_toprock_suicidedrop: {
    name: "TopRock ‚Üí Suicide Drop",
    type: "standing",
    boundary(lm, prev){
      function torsoTilt(curr){
        const s = mid(curr[LM.LEFT_SHOULDER], curr[LM.RIGHT_SHOULDER]);
        const h = mid(curr[LM.LEFT_HIP], curr[LM.RIGHT_HIP]);
        const v = {x: s.x-h.x, y: s.y-h.y};
        const up = {x:0, y:-1};
        const cos = (dot(v,up)) / (Math.hypot(v.x,v.y)*1 + 1e-6);
        return Math.acos(Math.min(1, Math.max(-1, cos))) * 180/Math.PI;
      }
      const wristsLow = (c)=> (c[LM.LEFT_WRIST].y > c[LM.LEFT_HIP].y*0.98) || (c[LM.RIGHT_WRIST].y > c[LM.RIGHT_HIP].y*0.98);
      try{
        if(!prev) return false;
        const t0 = torsoTilt(prev), t1 = torsoTilt(lm);
        const dT = Math.abs(t1 - t0);
        return (t1>50 && dT>6) && wristsLow(lm);
      }catch(e){ return false; }
    }
  }
};

function getTransitionProfile(id){ return TRANSITIONS[id] || TRANSITIONS['transition_ts']; }

let prevLm = null, prevTs = 0;
let speedHist = [], jerkHist = [], angleVelHist = [];
let boundaryTs = null;

function com(lm){ return mid(lm[LM.LEFT_HIP], lm[LM.RIGHT_HIP]); }
function horizSpeed(a,b,dt){ if(!a || !b || dt<=0) return 0; return Math.abs(b.x - a.x) / dt; }
function angleShoulderHipAnkle(lm, left=true){
  const S = left ? LM.LEFT_SHOULDER : LM.RIGHT_SHOULDER;
  const H = left ? LM.LEFT_HIP : LM.RIGHT_HIP;
  const A = left ? LM.LEFT_ANKLE : LM.RIGHT_ANKLE;
  return angle(lm[S], lm[H], lm[A]);
}
function lowPass(arr, k=5){
  if(!arr.length) return 0;
  const n = Math.min(k, arr.length); let s=0;
  for(let i=arr.length-n;i<arr.length;i++) s+=arr[i];
  return s/n;
}

async function init(){
  videoEl = document.getElementById('video');
  canvasEl = document.getElementById('overlay');
  ctx = canvasEl.getContext('2d');
  drawing = new DrawingUtils(ctx);

  updateMirror();
  setStatus('–∑–∞—Ä–µ–∂–¥–∞ –º–æ–¥–µ–ª‚Ä¶'); if(!window.isSecureContext){ logMsg('‚ö† file:// –º–æ–∂–µ –¥–∞ –±–ª–æ–∫–∏—Ä–∞ –∫–∞–º–µ—Ä–∞—Ç–∞. –ü–æ–ª–∑–≤–∞–π HTTPS –∏–ª–∏ –ª–æ–∫–∞–ª–µ–Ω —Å—ä—Ä–≤—ä—Ä.'); }

  const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
  try {
    landmarker = await PoseLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
        delegate:"GPU"
      },
      runningMode: "VIDEO",
      numPoses: 1,
      minPoseDetectionConfidence: 0.5,
      minPosePresenceConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    setStatus('–º–æ–¥–µ–ª: –≥–æ—Ç–æ–≤');
  } catch(e){
    setStatus('–ü—Ä–æ–±–ª–µ–º –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –º–æ–¥–µ–ª–∞: '+e.message);
  }
}

function updateMirror(){
  const mirrored = document.getElementById('mirror').checked;
  videoEl.style.transform = mirrored ? 'scaleX(-1)' : 'scaleX(1)';
  canvasEl.style.transform = mirrored ? 'scaleX(-1)' : 'scaleX(1)';
}

async function startCamera(){
  if(!window.isSecureContext){
    setStatus("–ù—É–∂–Ω–æ –µ HTTPS –∏–ª–∏ localhost, –∏–Ω–∞—á–µ –∫–∞–º–µ—Ä–∞—Ç–∞ –µ –±–ª–æ–∫–∏—Ä–∞–Ω–∞.");
    logMsg("–°—ä–≤–µ—Ç: –æ—Ç–≤–æ—Ä–∏ —Ñ–∞–π–ª–∞ –ø–æ HTTPS –∏–ª–∏ –ø—Ä–µ–∑ –ª–æ–∫–∞–ª–µ–Ω —Å—ä—Ä–≤—ä—Ä.");
    alert("–ö–∞–º–µ—Ä–∞—Ç–∞ –µ –±–ª–æ–∫–∏—Ä–∞–Ω–∞ –∑–∞ file:// —Å—Ç—Ä–∞–Ω–∏—Ü–∏.");
  }
  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    setStatus("getUserMedia –Ω–µ –µ –Ω–∞–ª–∏—á–Ω–æ –≤ —Ç–æ–∑–∏ –±—Ä–∞—É–∑—ä—Ä."); return;
  }
  const desiredFacing = document.getElementById('facing').value;
  let constraintsList = [
    { video: { facingMode: { ideal: desiredFacing } }, audio:false },
    { video: { facingMode: 'user' }, audio:false },
    { video: true, audio:false }
  ];
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const hasBack = devices.some(d=> d.kind==='videoinput' && /back|rear|environment/i.test(d.label));
    if(!hasBack && desiredFacing==='environment'){
      constraintsList = constraintsList.slice(1);
      logMsg("–ù–µ –æ—Ç–∫—Ä–∏—Ö –∑–∞–¥–Ω–∞ –∫–∞–º–µ—Ä–∞. –ü—Ä–µ–º–∏–Ω–∞–≤–∞–º –∫—ä–º –ø—Ä–µ–¥–Ω–∞.");
    }
  }catch(e){ logMsg("enumerateDevices –≥—Ä–µ—à–∫–∞: "+e.message); }

  let stream = null;
  for(const c of constraintsList){
    try{ stream = await navigator.mediaDevices.getUserMedia(c); logMsg("–ö–∞–º–µ—Ä–∞ —Å—Ç–∞—Ä—Ç–∏—Ä–∞ —Å: "+JSON.stringify(c)); break; }
    catch(err){ logMsg("–ü—Ä–æ–≤–∞–ª —Å "+JSON.stringify(c)+": "+err.name+" / "+err.message); }
  }
  if(!stream){ setStatus("–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –¥–æ—Å—Ç—ä–ø –¥–æ –∫–∞–º–µ—Ä–∞—Ç–∞."); return; }

  try{
    videoEl.srcObject = stream;
    await new Promise(res => videoEl.onloadeddata = res);
    canvasEl.width = videoEl.videoWidth || 1280;
    canvasEl.height = videoEl.videoHeight || 720;
    running = true;
    setStatus("–∫–∞–º–µ—Ä–∞: –∞–∫—Ç–∏–≤–Ω–∞");
    predictLoop();
  }catch(e){ setStatus("–ü—Ä–æ–±–ª–µ–º –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –≤–∏–¥–µ–æ: "+e.message); }
}

function setScore(val){
  const el = document.getElementById('score');
  el.textContent = isFinite(val) ? String(val) : '‚Äî';
  el.classList.remove('good','ok','bad');
  if(!isFinite(val)) return;
  el.classList.add(val>=80 ? 'good' : val>=60 ? 'ok' : 'bad');
}
function setTempo(val){
  const el = document.getElementById('tempo');
  if(!val){ el.textContent = '‚Äî'; return; }
  const avg = bpmAvg.length ? (bpmAvg.reduce((a,b)=>a+b,0)/bpmAvg.length) : val;
  el.textContent = Math.round(avg) + ' —Å—Ç—ä–ø–∫–∏/–º–∏–Ω';
}
function setTips(list){
  const el = document.getElementById('tips');
  el.innerHTML = '';
  list.slice(0,4).forEach(t=>{
    const d = document.createElement('span');
    d.className = 'tip';
    d.textContent = t;
    el.appendChild(d);
  });
  if(list.length && document.getElementById('voice').checked){ speak(list[0]); }
}

function transitionScoreAndTips(){
  if(boundaryTs===null){
    const s = lowPass(speedHist, 10);
    const tips = [];
    if(s<0.002) tips.push("–ü–æ–¥–≥–æ—Ç–≤–∏ –≤—Ö–æ–¥–∞: –¥–≤–∏–∂–∏ —Ü–µ–Ω—Ç—ä—Ä–∞/—ä–≥—ä–ª–∞ –ø–ª–∞–≤–Ω–æ.");
    tips.push("–í–ª–µ–∑ –±–µ–∑ –¥–∞ –≥—É–±–∏—à –∏–Ω–µ—Ä—Ü–∏—è.");
    return {score: Math.round(Math.min(100, s*60000)), tips};
  }
  const N = Math.min(speedHist.length, 36);
  const half = Math.floor(N/2);
  const pre = speedHist.slice(Math.max(0,speedHist.length-N), Math.max(0,speedHist.length-N)+half);
  const post = speedHist.slice(Math.max(0,speedHist.length-N)+half);
  const sPre = pre.length ? pre.reduce((a,b)=>a+b,0)/pre.length : 0;
  const sPost = post.length ? post.reduce((a,b)=>a+b,0)/post.length : 0;
  const jerkAvg = (jerkHist.slice(-N).reduce((a,b)=>a+b,0))/Math.max(1,Math.min(N,jerkHist.length));
  const angleVel = (angleVelHist.slice(-N).reduce((a,b)=>a+b,0))/Math.max(1,Math.min(N,angleVelHist.length));

  const retention = sPre>0 ? (sPost/sPre) : 0;
  const jerkScore = Math.max(0, 1 - (jerkAvg / 0.08));
  const angScore = Math.max(0, 1 - (angleVel / 180));
  const combined = (0.5*retention + 0.3*jerkScore + 0.2*angScore);
  const score = Math.round(100 * Math.max(0, Math.min(1, combined)));

  const tips = [];
  if(retention<0.7) tips.push("–ó–∞–ø–∞–∑–∏ —Å–∫–æ—Ä–æ—Å—Ç—Ç–∞ –ø—Ä–µ–∑ –≤—Ö–æ–¥–∞.");
  if(jerkScore<0.7) tips.push("–û–º–µ–∫–æ—Ç–∏ —Ä—è–∑–∫–∞—Ç–∞ –ø—Ä–æ–º—è–Ω–∞.");
  if(angScore<0.7) tips.push("–ü–ª–∞–≤–Ω–∏ —ä–≥–ª–∏ –≤ –ø—Ä–µ—Ö–æ–¥–∞.");

  return {score, tips};
}

function scoreAndTips(lm, moveId){
  const move = MOVES[moveId];
  const tips = [];
  let okCount = 0;
  for(const c of move.constraints){
    const pass = safeTest(()=>c.test(lm));
    if(pass) okCount++; else tips.push(c.tip);
  }
  const score = Math.round(100 * okCount / move.constraints.length);
  return {score, tips};
}
function safeTest(fn){ try{ return !!fn(); } catch(e){ return false; } }

async function predictLoop(){
  if(!running) return;
  const now = performance.now();

  if(videoEl.currentTime !== lastVideoTime){
    lastVideoTime = videoEl.currentTime;

    // ‚úÖ –ø—Ä–∞–≤–∏–ª–Ω–æ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ –Ω–∞ API-—Ç–æ:
    const res = landmarker.detectForVideo(videoEl, now);

    ctx.clearRect(0,0,canvasEl.width, canvasEl.height);
    if(res && res.landmarks && res.landmarks[0]){
      const lm = res.landmarks[0];
      drawing.drawLandmarks(lm, { radius: (data)=> DrawingUtils.lerp(data.from?.z ?? 0, -0.15, 0.1, 5, 1) });
      drawing.drawConnectors(lm, PoseLandmarker.POSE_CONNECTIONS);

      const moveId = document.getElementById('move').value;

      if(moveId.startsWith('transition_')){
        const prof = getTransitionProfile(moveId);
        const nowTs = performance.now()/1000;

        if(prof.boundary(lm, prevLm) && boundaryTs===null){ boundaryTs = nowTs; speak("–í—Ö–æ–¥!"); }

        const dt = (prevTs? nowTs - prevTs : 0.033);
        if(prevLm && dt>0){
          if(prof.type === 'floor'){
            const aPrev = 0.5*(angleShoulderHipAnkle(prevLm,true)+angleShoulderHipAnkle(prevLm,false));
            const aNow  = 0.5*(angleShoulderHipAnkle(lm,true)+angleShoulderHipAnkle(lm,false));
            const aVel = Math.abs(aNow - aPrev)/dt;
            speedHist.push(aVel/180); if(speedHist.length>60) speedHist.shift();
            const n = speedHist.length;
            if(n>=2){ const jerk = Math.abs(speedHist[n-1]-speedHist[n-2])/dt; jerkHist.push(jerk); if(jerkHist.length>60) jerkHist.shift(); }
            angleVelHist.push(aVel); if(angleVelHist.length>60) angleVelHist.shift();
          } else {
            const cPrev = com(prevLm); const cNow = com(lm);
            const v = horizSpeed(cPrev, cNow, dt);
            speedHist.push(v); if(speedHist.length>60) speedHist.shift();
            const n = speedHist.length;
            if(n>=2){ const jerk = Math.abs(speedHist[n-1]-speedHist[n-2])/dt; jerkHist.push(jerk); if(jerkHist.length>60) jerkHist.shift(); }
            const aPrev = 0.5*(angleShoulderHipAnkle(prevLm,true)+angleShoulderHipAnkle(prevLm,false));
            const aNow  = 0.5*(angleShoulderHipAnkle(lm,true)+angleShoulderHipAnkle(lm,false));
            const aVel = Math.abs(aNow - aPrev)/dt;
            angleVelHist.push(aVel); if(angleVelHist.length>60) angleVelHist.shift();
          }
        }
        prevLm = lm; prevTs = nowTs;

        const {score, tips} = transitionScoreAndTips();
        if(moveId==='transition_indian_kneedrop') tips.unshift("–°–≤–∞–ª–∏ –∫–æ–ª—è–Ω–æ—Ç–æ –ø–ª–∞–≤–Ω–æ –≤ —Ç–∞–∫—Ç.");
        if(moveId==='transition_toprock_drop') tips.unshift("–ü—É—Å–Ω–∏ —Ä—ä—Ü–µ –∫—ä–º –ø–æ–¥–∞ –±–µ–∑ —Å–ø–∏—Ä–∞–Ω–µ.");
        if(moveId==='transition_sixstep_babyfreeze') tips.unshift("–ü—Ä–µ—Ç–µ–≥–ª–∏ –Ω–∞ —Ä—ä—Ü–µ –∏ –∑–∞–∫–ª—é—á–∏ –±–µ–±–µ-—Ñ—Ä–∏–π–∑–∞ –≥–ª–∞–¥–∫–æ.");
        if(moveId==='transition_toprock_kneedrop') tips.unshift("–ú–µ–∫–∏ –∫–æ–ª–µ–Ω–µ, –ø–∞–∑–∏ –∏–Ω–µ—Ä—Ü–∏—è—Ç–∞ –∫—ä–º –ø–æ–¥–∞.");
        if(moveId==='transition_toprock_sweepdrop') tips.unshift("–®–∏—Ä–æ–∫ sweep –∏ –ø–ª–∞–≤–µ–Ω –∫–æ–Ω—Ç—Ä–æ–ª –∫—ä–º –ø–æ–¥–∞.");
        if(moveId==='transition_toprock_spindrop') tips.unshift("–ü–æ–¥–¥—ä—Ä–∂–∞–π –≤—ä—Ä—Ç–µ–Ω–µ—Ç–æ ‚Äì –Ω–µ —Å–ø–∏—Ä–∞–π –ø—Ä–µ–¥–∏ —Å–ø—É—Å–∫–∞–Ω–µ—Ç–æ.");
        if(moveId==='transition_toprock_hookdrop') tips.unshift("–•—É–∫—ä—Ç –¥–∞ –µ —è—Å–µ–Ω, –Ω–æ –±–µ–∑ –±–ª–æ–∫–∏—Ä–∞–Ω–µ.");
        if(moveId==='transition_toprock_collapsedrop') tips.unshift("–ò–∑–≥–ª–µ–∂–¥–∞–π –∫–∞—Ç–æ ‚Äû–ø–∞–¥–∞–Ω–µ‚Äú, –Ω–æ –±–µ–∑ –¥–∞ –≥—É–±–∏—à flow.");
        if(moveId==='transition_toprock_rolldrop') tips.unshift("–°–Ω–∏–∑—Ö–æ–¥ –ø—Ä–µ–∑ —Ä–∞–º–æ, –∑–∞–¥—Ä—ä–∂ –∫—Ä—ä–≥–æ–≤–∞—Ç–∞ –µ–Ω–µ—Ä–≥–∏—è.");
        if(moveId==='transition_toprock_suicidedrop') tips.unshift("–ö–æ–º–∏—Ç–Ω–∞—Ç –≤—Ö–æ–¥, –ø–æ—Å–ª–µ —Å—Ç–∞–±–∏–ª–µ–Ω –∫–æ–Ω—Ç—Ä–æ–ª.");
        setScore(score); setTips(tips); setTempo(null);

      } else {
        boundaryTs = null; prevLm=null; prevTs=0; speedHist.length=0; jerkHist.length=0; angleVelHist.length=0;
        const {score, tips} = scoreAndTips(lm, moveId);
        setScore(score); setTips(tips);
        if(moveId === 'toprock' && MOVES.toprock.stepDetector){
          const bpm = MOVES.toprock.stepDetector(lm, performance.now()/1000);
          if(bpm) setTempo(bpm);
        } else { setTempo(null); }
      }
    } else {
      setScore(NaN);
      setTips(["–ü–æ–∫–∞–∂–∏ —Ü—è–ª–æ —Ç—è–ª–æ –≤ –∫–∞–¥—ä—Ä."]);
      setTempo(null);
    }
  }
  requestAnimationFrame(predictLoop);
}

document.getElementById('btnStart').addEventListener('click', startCamera);
document.getElementById('mirror').addEventListener('change', updateMirror);

function safeTest(fn){ try{ return !!fn(); } catch(e){ return false; } }

init();
</script>
</body>
</html>
